use std::vec;
use ast::{AssignmentOperator,Comparator,Literal,Operator,Node,Punctuator};

grammar;

match {
  r"\x09|\x0B|\x0C|\xFEFF|\p{Space_Separator}" => Whitespace,
  r"\u000A|\u000D|\u2028|\u2029" => LineTerminator,
  r"0|[1-9][0-9]*" => DecimalIntegerLiteral,
  r"[eE][+-]?[0-9]+" => ExponentPart,
  r"//[^\u000A\u000D\u2028\u2029]*" => SingleLineComment,
  r"/\*((?:\*[^/])|[^*])*\*/" => MultiLineComment,
  // TODO Unicode escape sequences
  r"\p{ID_Start}|\$|_(?:\p{ID_Continue}|\$|\u200C|\u200D)*" => IdentifierName,
  _
}

pub InputElementDiv: Node = {
  Whitespace => Node::Whitespace(<>.to_string()),
  LineTerminator => Node::Whitespace(<>.to_string()),
  Comment,
  CommonToken,
  DivPunctuator,
  RightBracePunctuator
};

Comment: Node = {
  SingleLineComment => Node::Comment(false, <>.to_string()),
  MultiLineComment => Node::Comment(true, <>.to_string()),
};

DivPunctuator: Node = {
  "/" => Node::Operator(Operator::Divide),
  "/=" => Node::AssignmentOperator(AssignmentOperator::Divide),
}

RightBracePunctuator: Node = {
  "}" => Node::Punctuator(Punctuator::RightBrace),
};

CommonToken: Node = {
  IdentifierName => Node::Identifier(<>.to_string()),
  Punctuator,
  NumericLiteral,
  StringLiteral,
//   Template,
}

NumericLiteral: Node = {
  DecimalLiteral,
  BinaryIntegerLiteral,
  OctalIntegerLiteral,
  HexIntegerLiteral,
};

DecimalLiteral: Node = {
  <i:DecimalIntegerLiteral?> <d:r"\.[0-9]*"> <e:ExponentPart?> => {
    let mut s = "".to_string();
    i.map(|x| s.push_str(&x.to_string()));
    s.push_str(&d);
    e.map(|x| s.push_str(&x.to_string()));
    Node::Literal(Literal::Numeric(s))
  },
  <i:DecimalIntegerLiteral> <e:ExponentPart?> => {
    let mut s = i.to_string();
    e.map(|x| s.push_str(&x.to_string()));
    Node::Literal(Literal::Numeric(s))
  }
};

BinaryIntegerLiteral: Node = {
  r"0[bB][01]+" => Node::Literal(Literal::Numeric(<>.to_string()))
};

OctalIntegerLiteral: Node = {
  r"0[oO][0-7]+" => Node::Literal(Literal::Numeric(<>.to_string()))
};

HexIntegerLiteral: Node = {
  r"0[xX][0-9a-fA-F]+" => Node::Literal(Literal::Numeric(<>.to_string()))
};

StringLiteral: Node = {
  // "\"" <s:DoubleStringCharacters> "\"" => Node::Literal(Literal::String(s))
  "'" <s:SingleStringCharacters*> "'" => {
    let s = s.fold(|acc, x| acc.push_str(x));
    Node::Literal(Literal::String(s))
  }
};

SingleStringCharacters: String = {
  r"[^'\\u000A\u000D\u2028\u2029]" => <>.to_string(),
  "\\" <s:EscapeSequence> => s,
  "\\" <s:LineTerminatorSequence> => s
};

EscapeSequence: String = {
  CharacterEscapeSequence,
  r"0[^0-9]" => <>.to_string(),
  r"x[a-fA-F0-9]{2}" => <>.to_string(),
  r"u[a-fA-F0-9]{4}" => <>.to_string(),
  r"u\{[a-fA-F0-9]\}{4}" => <>.to_string(),
};

CharacterEscapeSequence: String = {
  r#"['"bfnrtv]"# => <>.to_string(),
  r#"[^xu0-9'"bfnrtv\u000A\u000D\u2028\u2029]"# => <>.to_string()
};

LineTerminatorSequence: String = {
  r"\u000A|\u2028|\u2029|\u000D\u000A|\u000D" => <>.to_string()
};

Punctuator: Node = {
  "{"    => Node::Punctuator(Punctuator::LeftBrace),
  "("    => Node::Punctuator(Punctuator::LeftParen),
  ")"    => Node::Punctuator(Punctuator::RightParen),
  "["    => Node::Punctuator(Punctuator::LeftBracket),
  "]"    => Node::Punctuator(Punctuator::RightBracket),
  "."    => Node::Punctuator(Punctuator::Dot),
  "..."  => Node::Punctuator(Punctuator::Ellipsis),
  ";"    => Node::Punctuator(Punctuator::Semicolon),
  ","    => Node::Punctuator(Punctuator::Comma),
  "~"    => Node::Punctuator(Punctuator::Tilde),
  "?"    => Node::Punctuator(Punctuator::Question),
  ":"    => Node::Punctuator(Punctuator::Colon),
  "=>"   => Node::Punctuator(Punctuator::Arrow),
  "<"    => Node::Comparator(Comparator::LT),
  ">"    => Node::Comparator(Comparator::GT),
  "<="   => Node::Comparator(Comparator::LTE),
  ">="   => Node::Comparator(Comparator::GTE),
  "=="   => Node::Comparator(Comparator::EQ),
  "!="   => Node::Comparator(Comparator::NEQ),
  "==="  => Node::Comparator(Comparator::EEQ),
  "!=="  => Node::Comparator(Comparator::NEEQ),
  "+"    => Node::Operator(Operator::Plus),
  "-"    => Node::Operator(Operator::Minus),
  "*"    => Node::Operator(Operator::Times),
  "%"    => Node::Operator(Operator::Mod),
  "**"   => Node::Operator(Operator::Pow),
  "++"   => Node::Operator(Operator::Inc),
  "--"   => Node::Operator(Operator::Dec),
  "<<"   => Node::Operator(Operator::ShiftLeft),
  ">>"   => Node::Operator(Operator::ShiftRight),
  ">>>"  => Node::Operator(Operator::ShiftRightRight),
  "&"    => Node::Operator(Operator::BinaryAnd),
  "|"    => Node::Operator(Operator::BinaryOr),
  "^"    => Node::Operator(Operator::BinaryNot),
  "!"    => Node::Operator(Operator::LogicalNot),
  "&&"   => Node::Operator(Operator::LogicalAnd),
  "||"   => Node::Operator(Operator::LogicalOr),
  "="    => Node::AssignmentOperator(AssignmentOperator::Equals),
  "+="   => Node::AssignmentOperator(AssignmentOperator::Plus),
  "*="   => Node::AssignmentOperator(AssignmentOperator::Times),
  "%="   => Node::AssignmentOperator(AssignmentOperator::Mod),
  "**="  => Node::AssignmentOperator(AssignmentOperator::Pow),
  "<<="  => Node::AssignmentOperator(AssignmentOperator::ShiftLeft),
  ">>="  => Node::AssignmentOperator(AssignmentOperator::ShiftRight),
  ">>>=" => Node::AssignmentOperator(AssignmentOperator::ShiftRightRight),
  "&="   => Node::AssignmentOperator(AssignmentOperator::BinaryAnd),
  "|="   => Node::AssignmentOperator(AssignmentOperator::BinaryOr),
  "^="   => Node::AssignmentOperator(AssignmentOperator::BinaryNot),
};
