use ast::{AssignmentOperator,Comparator,Literal,Operator,Node,Punctuator};

grammar;

match {
    r"0|[1-9][0-9]*" => DecimalIntegerLiteral,
    r"[eE][+-]?[0-9]+" => ExponentPart,
    r"//[^\u000A\u000D\u2028\u2029]*" => SingleLineComment,
    r"/\*((?:\*[^/])|[^*])*\*/" => MultiLineComment,
    // TODO Unicode escape sequences
    r"\p{ID_Start}|\$|_(?:\p{ID_Continue}|\$|\u200C|\u200D)*" => IdentifierName,
    _
}

pub InputElementDiv: Node = {
    Whitespace => Node::Whitespace(<>.to_string()),
    LineTerminator => Node::Whitespace(<>.to_string()),
    Comment,
    CommonToken,
    DivPunctuator,
    RightBracePunctuator,
};

pub InputElementRegExp: Node = {
    Whitespace,
    LineTerminator,
    Comment,
    CommonToken,
    RightBracePunctuator,
    RegularExpressionLiteral,
};

Whitespace: Node = {
    r"\x09|\x0B|\x0C|\xFEFF|\p{Space_Separator}" => <>.to_string(),
};

LineTerminator: Node = {
    r"\u000A|\u000D|\u2028|\u2029" => <>.to_string(),
};

Comment: Node = {
    SingleLineComment => Node::Comment(false, <>.to_string()),
    MultiLineComment => Node::Comment(true, <>.to_string()),
};

DivPunctuator: Node = {
    "/" => Node::Operator(Operator::Divide),
    "/=" => Node::AssignmentOperator(AssignmentOperator::Divide),
}

RightBracePunctuator: Node = {
    "}" => Node::Punctuator(Punctuator::RightBrace),
};

CommonToken: Node = {
    IdentifierName => Node::Identifier(<>.to_string()),
    Punctuator,
    NumericLiteral,
    StringLiteral,
    Template,
}

NumericLiteral: Node = {
    DecimalLiteral,
    BinaryIntegerLiteral,
    OctalIntegerLiteral,
    HexIntegerLiteral,
};

DecimalLiteral: Node = {
    <i:DecimalIntegerLiteral?> <d:r"\.[0-9]*"> <e:ExponentPart?> => {
        let mut s = "".to_string();
        i.map(|x| s.push_str(&x.to_string()));
        s.push_str(&d);
        e.map(|x| s.push_str(&x.to_string()));
        Node::Literal(Literal::Numeric(s))
    },
    <i:DecimalIntegerLiteral> <e:ExponentPart?> => {
        let mut s = i.to_string();
        e.map(|x| s.push_str(&x.to_string()));
        Node::Literal(Literal::Numeric(s))
    }
};

BinaryIntegerLiteral: Node = {
    r"0[bB][01]+" => Node::Literal(Literal::Numeric(<>.to_string()))
};

OctalIntegerLiteral: Node = {
    r"0[oO][0-7]+" => Node::Literal(Literal::Numeric(<>.to_string()))
};

HexIntegerLiteral: Node = {
    r"0[xX][0-9a-fA-F]+" => Node::Literal(Literal::Numeric(<>.to_string()))
};

StringLiteral: Node = {
    DoubleStringCharacters => Node::Literal(Literal::String(<>.to_string())),
    SingleStringCharacters => Node::Literal(Literal::String(<>.to_string())),
};

SingleStringCharacters: String = {
    r#"'(?:[^'\\x0A\x0D\u2028\u2029]|(?:\\(?:['"bfnrtv0]|x[a-fA-F0-9]{2}|u[a-fA-F0-9]{2}|u\\\{[a-fA-F0-9]\}{4}))|(?:\\[\x0A|\u2028|\u2029|\x0D\x0A|\x0D]))*'"# => <>.to_string(),
};

DoubleStringCharacters: String = {
    r#""(?:[^"\\x0A\x0D\u2028\u2029]|(?:\\(?:['"bfnrtv0]|x[a-fA-F0-9]{2}|u[a-fA-F0-9]{2}|u\\\{[a-fA-F0-9]\}{4}))|(?:\\[\x0A|\u2028|\u2029|\x0D\x0A|\x0D]))*""# => <>.to_string(),
};

Template: Node = {
    r"`(?:[^`](?:\$\{)|`)*" => Node::Literal(Literal::Template(<>.to_string())),
};

Punctuator: Node = {
    "{"    => Node::Punctuator(Punctuator::LeftBrace),
    "("    => Node::Punctuator(Punctuator::LeftParen),
    ")"    => Node::Punctuator(Punctuator::RightParen),
    "["    => Node::Punctuator(Punctuator::LeftBracket),
    "]"    => Node::Punctuator(Punctuator::RightBracket),
    "."    => Node::Punctuator(Punctuator::Dot),
    "..."  => Node::Punctuator(Punctuator::Ellipsis),
    ";"    => Node::Punctuator(Punctuator::Semicolon),
    ","    => Node::Punctuator(Punctuator::Comma),
    "~"    => Node::Punctuator(Punctuator::Tilde),
    "?"    => Node::Punctuator(Punctuator::Question),
    ":"    => Node::Punctuator(Punctuator::Colon),
    "=>"   => Node::Punctuator(Punctuator::Arrow),
    "<"    => Node::Comparator(Comparator::LT),
    ">"    => Node::Comparator(Comparator::GT),
    "<="   => Node::Comparator(Comparator::LTE),
    ">="   => Node::Comparator(Comparator::GTE),
    "=="   => Node::Comparator(Comparator::EQ),
    "!="   => Node::Comparator(Comparator::NEQ),
    "==="  => Node::Comparator(Comparator::EEQ),
    "!=="  => Node::Comparator(Comparator::NEEQ),
    "+"    => Node::Operator(Operator::Plus),
    "-"    => Node::Operator(Operator::Minus),
    "*"    => Node::Operator(Operator::Times),
    "%"    => Node::Operator(Operator::Mod),
    "**"   => Node::Operator(Operator::Pow),
    "++"   => Node::Operator(Operator::Inc),
    "--"   => Node::Operator(Operator::Dec),
    "<<"   => Node::Operator(Operator::ShiftLeft),
    ">>"   => Node::Operator(Operator::ShiftRight),
    ">>>"  => Node::Operator(Operator::ShiftRightRight),
    "&"    => Node::Operator(Operator::BinaryAnd),
    "|"    => Node::Operator(Operator::BinaryOr),
    "^"    => Node::Operator(Operator::BinaryNot),
    "!"    => Node::Operator(Operator::LogicalNot),
    "&&"   => Node::Operator(Operator::LogicalAnd),
    "||"   => Node::Operator(Operator::LogicalOr),
    "="    => Node::AssignmentOperator(AssignmentOperator::Equals),
    "+="   => Node::AssignmentOperator(AssignmentOperator::Plus),
    "*="   => Node::AssignmentOperator(AssignmentOperator::Times),
    "%="   => Node::AssignmentOperator(AssignmentOperator::Mod),
    "**="  => Node::AssignmentOperator(AssignmentOperator::Pow),
    "<<="  => Node::AssignmentOperator(AssignmentOperator::ShiftLeft),
    ">>="  => Node::AssignmentOperator(AssignmentOperator::ShiftRight),
    ">>>=" => Node::AssignmentOperator(AssignmentOperator::ShiftRightRight),
    "&="   => Node::AssignmentOperator(AssignmentOperator::BinaryAnd),
    "|="   => Node::AssignmentOperator(AssignmentOperator::BinaryOr),
    "^="   => Node::AssignmentOperator(AssignmentOperator::BinaryNot),
};

RegularExpressionLiteral: Node = {
    r"/(?:[^*\\/[LineTerminator]|\\[^LineTerminator]|\[(?:)*\])(?:)*/(?:\p{ID_Continue}|\$|($:\\u\{?[a-fA-F0-9]{4}\}?)|\u200C|\u200D)*" => Node::Literal(Literal::RegExp(<>.to_string()))
};

// vim: ft=rust
